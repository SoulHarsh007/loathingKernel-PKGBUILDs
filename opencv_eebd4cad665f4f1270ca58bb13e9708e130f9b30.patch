diff --git a/3rdparty/openexr/CMakeLists.txt b/3rdparty/openexr/CMakeLists.txt
index c4facad..dd9a0e7 100644
--- a/3rdparty/openexr/CMakeLists.txt
+++ b/3rdparty/openexr/CMakeLists.txt
@@ -38,6 +38,7 @@ source_group("Include" FILES ${lib_hdrs} )
 source_group("Src" FILES ${lib_srcs})
 
 ocv_warnings_disable(CMAKE_CXX_FLAGS -Wshadow -Wunused -Wsign-compare -Wundef -Wmissing-declarations -Wuninitialized -Wswitch -Wparentheses -Warray-bounds -Wextra)
+ocv_warnings_disable(CMAKE_CXX_FLAGS -Wdeprecated-declarations)
 ocv_warnings_disable(CMAKE_CXX_FLAGS /wd4018 /wd4099 /wd4100 /wd4101 /wd4127 /wd4189 /wd4245 /wd4305 /wd4389 /wd4512 /wd4701 /wd4702 /wd4706 /wd4800) # vs2005
 ocv_warnings_disable(CMAKE_CXX_FLAGS /wd4334) # vs2005 Win64
 ocv_warnings_disable(CMAKE_CXX_FLAGS /wd4244) # vs2008
diff --git a/cmake/FindCUDA.cmake b/cmake/FindCUDA.cmake
index 5efd36c..34a7e94 100644
--- a/cmake/FindCUDA.cmake
+++ b/cmake/FindCUDA.cmake
@@ -639,13 +639,13 @@ mark_as_advanced(CUDA_TARGET_OS_VARIANT)
 # Target triplet
 if(DEFINED CUDA_TARGET_TRIPLET)
   set(_cuda_target_triplet_initial "${CUDA_TARGET_TRIPLET}")
-elseif(CUDA_VERSION VERSION_GREATER "5.0" AND CMAKE_CROSSCOMPILING AND "${CUDA_TARGET_CPU_ARCH}" STREQUAL "ARM")
+elseif(CUDA_VERSION VERSION_GREATER "5.0" AND CMAKE_CROSSCOMPILING AND "x${CUDA_TARGET_CPU_ARCH}" STREQUAL "xARM")
   if("${CUDA_TARGET_OS_VARIANT}" STREQUAL "Android" AND EXISTS "${CUDA_TOOLKIT_ROOT_DIR}/targets/armv7-linux-androideabi")
     set(_cuda_target_triplet_initial "armv7-linux-androideabi")
   elseif(EXISTS "${CUDA_TOOLKIT_ROOT_DIR}/targets/armv7-linux-gnueabihf")
     set(_cuda_target_triplet_initial "armv7-linux-gnueabihf")
   endif()
-elseif(CUDA_VERSION VERSION_GREATER "6.5" AND CMAKE_CROSSCOMPILING AND "${CUDA_TARGET_CPU_ARCH}" STREQUAL "AARCH64")
+elseif(CUDA_VERSION VERSION_GREATER "6.5" AND CMAKE_CROSSCOMPILING AND "x${CUDA_TARGET_CPU_ARCH}" STREQUAL "xAARCH64")
   if("${CUDA_TARGET_OS_VARIANT}" STREQUAL "Android" AND EXISTS "${CUDA_TOOLKIT_ROOT_DIR}/targets/aarch64-linux-androideabi")
     set(_cuda_target_triplet_initial "aarch64-linux-androideabi")
   elseif(EXISTS "${CUDA_TOOLKIT_ROOT_DIR}/targets/aarch64-linux-gnueabihf")
diff --git a/cmake/OpenCVDetectAndroidSDK.cmake b/cmake/OpenCVDetectAndroidSDK.cmake
index 2737589..a518d85 100644
--- a/cmake/OpenCVDetectAndroidSDK.cmake
+++ b/cmake/OpenCVDetectAndroidSDK.cmake
@@ -349,7 +349,7 @@ macro(add_android_project target path)
     if(android_proj_IGNORE_JAVA)
       add_custom_command(
          OUTPUT "${android_proj_bin_dir}/bin/${target}-debug.apk"
-         COMMAND ${ANT_EXECUTABLE} -q -noinput -k debug
+         COMMAND ${ANT_EXECUTABLE} -q -noinput -k debug -Djava.target=1.6 -Djava.source=1.6
          COMMAND ${CMAKE_COMMAND} -E touch "${android_proj_bin_dir}/bin/${target}-debug.apk" # needed because ant does not update the timestamp of updated apk
          WORKING_DIRECTORY "${android_proj_bin_dir}"
          MAIN_DEPENDENCY "${android_proj_bin_dir}/${ANDROID_MANIFEST_FILE}"
@@ -357,7 +357,7 @@ macro(add_android_project target path)
     else()
       add_custom_command(
          OUTPUT "${android_proj_bin_dir}/bin/${target}-debug.apk"
-         COMMAND ${ANT_EXECUTABLE} -q -noinput -k debug
+         COMMAND ${ANT_EXECUTABLE} -q -noinput -k debug -Djava.target=1.6 -Djava.source=1.6
          COMMAND ${CMAKE_COMMAND} -E touch "${android_proj_bin_dir}/bin/${target}-debug.apk" # needed because ant does not update the timestamp of updated apk
          WORKING_DIRECTORY "${android_proj_bin_dir}"
          MAIN_DEPENDENCY "${android_proj_bin_dir}/${ANDROID_MANIFEST_FILE}"
diff --git a/cmake/OpenCVPCHSupport.cmake b/cmake/OpenCVPCHSupport.cmake
index a7f8198..ad2bc8b 100644
--- a/cmake/OpenCVPCHSupport.cmake
+++ b/cmake/OpenCVPCHSupport.cmake
@@ -51,6 +51,25 @@ MACRO(_PCH_GET_COMPILE_FLAGS _out_compile_flags)
       ENDIF()
     endif()
 
+    IF(CMAKE_COMPILER_IS_GNUCXX)
+
+        GET_PROPERTY(_definitions DIRECTORY PROPERTY COMPILE_DEFINITIONS)
+        if(_definitions)
+          foreach(_def ${_definitions})
+            LIST(APPEND ${_out_compile_flags} "\"-D${_def}\"")
+          endforeach()
+        endif()
+        GET_TARGET_PROPERTY(_target_definitions ${_PCH_current_target} COMPILE_DEFINITIONS)
+        if(_target_definitions)
+          foreach(_def ${_target_definitions})
+            LIST(APPEND ${_out_compile_flags} "\"-D${_def}\"")
+          endforeach()
+        endif()
+
+    ELSE()
+        ## TODO ... ? or does it work out of the box
+    ENDIF()
+
     GET_DIRECTORY_PROPERTY(DIRINC INCLUDE_DIRECTORIES )
     FOREACH(item ${DIRINC})
         if(item MATCHES "^${OpenCV_SOURCE_DIR}/modules/")
@@ -60,11 +79,15 @@ MACRO(_PCH_GET_COMPILE_FLAGS _out_compile_flags)
         endif()
     ENDFOREACH(item)
 
-    GET_DIRECTORY_PROPERTY(_directory_flags DEFINITIONS)
-    GET_DIRECTORY_PROPERTY(_global_definitions DIRECTORY ${OpenCV_SOURCE_DIR} DEFINITIONS)
-    #MESSAGE("_directory_flags ${_directory_flags} ${_global_definitions}" )
-    LIST(APPEND ${_out_compile_flags} ${_directory_flags})
-    LIST(APPEND ${_out_compile_flags} ${_global_definitions})
+    get_target_property(DIRINC ${_PCH_current_target} INCLUDE_DIRECTORIES )
+    FOREACH(item ${DIRINC})
+        if(item MATCHES "^${OpenCV_SOURCE_DIR}/modules/")
+          LIST(APPEND ${_out_compile_flags} "${_PCH_include_prefix}\"${item}\"")
+        else()
+          LIST(APPEND ${_out_compile_flags} "${_PCH_isystem_prefix}\"${item}\"")
+        endif()
+    ENDFOREACH(item)
+
     LIST(APPEND ${_out_compile_flags} ${CMAKE_CXX_FLAGS})
 
     SEPARATE_ARGUMENTS(${_out_compile_flags})
@@ -146,9 +169,9 @@ MACRO(_PCH_GET_TARGET_COMPILE_FLAGS _cflags  _header_name _pch_path _dowarn )
         # if you have different versions of the headers for different build types
         # you may set _pch_dowarn
         IF (_dowarn)
-            set(${_cflags} "${PCH_ADDITIONAL_COMPILER_FLAGS} -Winvalid-pch")
+            SET(${_cflags} "${PCH_ADDITIONAL_COMPILER_FLAGS} -include \"${CMAKE_CURRENT_BINARY_DIR}/${_header_name}\" -Winvalid-pch " )
         ELSE (_dowarn)
-            set(${_cflags} "${PCH_ADDITIONAL_COMPILER_FLAGS}")
+            SET(${_cflags} "${PCH_ADDITIONAL_COMPILER_FLAGS} -include \"${CMAKE_CURRENT_BINARY_DIR}/${_header_name}\" " )
         ENDIF (_dowarn)
 
     ELSE(CMAKE_COMPILER_IS_GNUCXX)
@@ -246,12 +269,15 @@ MACRO(ADD_PRECOMPILED_HEADER _targetName _input)
         endif()
     endif()
 
+    get_target_property(DIRINC ${_targetName} INCLUDE_DIRECTORIES)
+    set_target_properties(${_targetName}_pch_dephelp PROPERTIES INCLUDE_DIRECTORIES "${DIRINC}")
+
     #MESSAGE("_compile_FLAGS: ${_compile_FLAGS}")
     #message("COMMAND ${CMAKE_CXX_COMPILER}	${_compile_FLAGS} -x c++-header -o ${_output} ${_input}")
 
     ADD_CUSTOM_COMMAND(
       OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/${_name}"
-      COMMAND ${CMAKE_COMMAND} -E copy  "${_input}" "${CMAKE_CURRENT_BINARY_DIR}/${_name}" # ensure same directory! Required by gcc
+      COMMAND ${CMAKE_COMMAND} -E copy_if_different "${_input}" "${CMAKE_CURRENT_BINARY_DIR}/${_name}" # ensure same directory! Required by gcc
       DEPENDS "${_input}"
       )
 
diff --git a/modules/calib3d/test/test_cameracalibration.cpp b/modules/calib3d/test/test_cameracalibration.cpp
index d5e4af5..0cc5701 100644
--- a/modules/calib3d/test/test_cameracalibration.cpp
+++ b/modules/calib3d/test/test_cameracalibration.cpp
@@ -1480,7 +1480,7 @@ void CV_StereoCalibrationTest::run( int )
 
         if( norm(R1t*R1 - eye33) > 0.01 ||
             norm(R2t*R2 - eye33) > 0.01 ||
-            abs(determinant(F)) > 0.01)
+            std::abs(determinant(F)) > 0.01)
         {
             ts->printf( cvtest::TS::LOG, "The computed (by rectify) R1 and R2 are not orthogonal,"
                 "or the computed (by calibrate) F is not singular, testcase %d\n", testcase);
@@ -1617,7 +1617,7 @@ void CV_StereoCalibrationTest::run( int )
         perspectiveTransform( _imgpt1, rectifPoints1, _H1 );
         perspectiveTransform( _imgpt2, rectifPoints2, _H2 );
 
-        bool verticalStereo = abs(P2.at<double>(0,3)) < abs(P2.at<double>(1,3));
+        bool verticalStereo = std::abs(P2.at<double>(0,3)) < std::abs(P2.at<double>(1,3));
         double maxDiff_c = 0, maxDiff_uc = 0;
         for( int i = 0, k = 0; i < nframes; i++ )
         {
@@ -1627,9 +1627,9 @@ void CV_StereoCalibrationTest::run( int )
 
             for( int j = 0; j < npoints; j++, k++ )
             {
-                double diff_c = verticalStereo ? abs(temp[0][j].x - temp[1][j].x) : abs(temp[0][j].y - temp[1][j].y);
+                double diff_c = verticalStereo ? std::abs(temp[0][j].x - temp[1][j].x) : std::abs(temp[0][j].y - temp[1][j].y);
                 Point2f d = rectifPoints1.at<Point2f>(k,0) - rectifPoints2.at<Point2f>(k,0);
-                double diff_uc = verticalStereo ? abs(d.x) : abs(d.y);
+                double diff_uc = verticalStereo ? std::abs(d.x) : std::abs(d.y);
                 maxDiff_c = max(maxDiff_c, diff_c);
                 maxDiff_uc = max(maxDiff_uc, diff_uc);
                 if( maxDiff_c > maxScanlineDistErr_c )
diff --git a/modules/calib3d/test/test_fisheye.cpp b/modules/calib3d/test/test_fisheye.cpp
index 6009106..07a6c08 100644
--- a/modules/calib3d/test/test_fisheye.cpp
+++ b/modules/calib3d/test/test_fisheye.cpp
@@ -381,7 +381,7 @@ TEST_F(fisheyeTest, EtimateUncertainties)
     EXPECT_MAT_NEAR(errors.c, cv::Vec2d(0.890439368129246, 0.816096854937896), 1e-10);
     EXPECT_MAT_NEAR(errors.k, cv::Vec4d(0.00516248605191506, 0.0168181467500934, 0.0213118690274604, 0.00916010877545648), 1e-10);
     EXPECT_MAT_NEAR(err_std, cv::Vec2d(0.187475975266883, 0.185678953263995), 1e-10);
-    CV_Assert(abs(rms - 0.263782587133546) < 1e-10);
+    CV_Assert(std::abs(rms - 0.263782587133546) < 1e-10);
     CV_Assert(errors.alpha == 0);
 }
 
diff --git a/modules/contrib/src/chamfermatching.cpp b/modules/contrib/src/chamfermatching.cpp
index 64d77cf..6066e74 100644
--- a/modules/contrib/src/chamfermatching.cpp
+++ b/modules/contrib/src/chamfermatching.cpp
@@ -966,10 +966,8 @@ void ChamferMatcher::Matching::computeDistanceTransform(Mat& edges_img, Mat& dis
     for (int y=0;y<h;++y) {
         for (int x=0;x<w;++x) {
             // initialize
-            if (&annotate_img!=NULL) {
-                annotate_img.at<Vec2i>(y,x)[0]=x;
-                annotate_img.at<Vec2i>(y,x)[1]=y;
-            }
+            annotate_img.at<Vec2i>(y,x)[0]=x;
+            annotate_img.at<Vec2i>(y,x)[1]=y;
 
             uchar edge_val = edges_img.at<uchar>(y,x);
             if( (edge_val!=0) ) {
@@ -1013,10 +1011,8 @@ void ChamferMatcher::Matching::computeDistanceTransform(Mat& edges_img, Mat& dis
                 dist_img.at<float>(ny,nx) = dist;
                 q.push(std::make_pair(nx,ny));
 
-                if (&annotate_img!=NULL) {
-                    annotate_img.at<Vec2i>(ny,nx)[0]=annotate_img.at<Vec2i>(y,x)[0];
-                    annotate_img.at<Vec2i>(ny,nx)[1]=annotate_img.at<Vec2i>(y,x)[1];
-                }
+                annotate_img.at<Vec2i>(ny,nx)[0]=annotate_img.at<Vec2i>(y,x)[0];
+                annotate_img.at<Vec2i>(ny,nx)[1]=annotate_img.at<Vec2i>(y,x)[1];
             }
         }
     }
@@ -1107,26 +1103,22 @@ ChamferMatcher::Match* ChamferMatcher::Matching::localChamferDistance(Point offs
 
     float cost = (sum_distance/truncate_)/addr.size();
 
+    float* optr = orientation_img.ptr<float>(y)+x;
+    float sum_orientation = 0;
+    int cnt_orientation = 0;
 
-    if (&orientation_img!=NULL) {
-        float* optr = orientation_img.ptr<float>(y)+x;
-        float sum_orientation = 0;
-        int cnt_orientation = 0;
+    for (size_t i=0;i<addr.size();++i) {
 
-        for (size_t i=0;i<addr.size();++i) {
-
-            if(addr[i] < (orientation_img.cols*orientation_img.rows) - (offset.y*orientation_img.cols + offset.x)){
-                                if (tpl->orientations[i]>=-CV_PI && (*(optr+addr[i]))>=-CV_PI) {
-                    sum_orientation += orientation_diff(tpl->orientations[i], (*(optr+addr[i])));
-                    cnt_orientation++;
-                }
+        if(addr[i] < (orientation_img.cols*orientation_img.rows) - (offset.y*orientation_img.cols + offset.x)){
+                            if (tpl->orientations[i]>=-CV_PI && (*(optr+addr[i]))>=-CV_PI) {
+                sum_orientation += orientation_diff(tpl->orientations[i], (*(optr+addr[i])));
+                cnt_orientation++;
             }
         }
+    }
 
-        if (cnt_orientation>0) {
-                        cost = (float)(beta*cost+alpha*(sum_orientation/(2*CV_PI))/cnt_orientation);
-        }
-
+    if (cnt_orientation>0) {
+                    cost = (float)(beta*cost+alpha*(sum_orientation/(2*CV_PI))/cnt_orientation);
     }
 
     if(cost > 0){
diff --git a/modules/highgui/src/cap_avfoundation.mm b/modules/highgui/src/cap_avfoundation.mm
index 13fccb5..9c9a456 100644
--- a/modules/highgui/src/cap_avfoundation.mm
+++ b/modules/highgui/src/cap_avfoundation.mm
@@ -913,7 +913,7 @@ IplImage* CvCaptureFile::retrieveFramePixelBuffer() {
     }
 
 
-    AVAssetReaderTrackOutput * output = [mMovieReader.outputs objectAtIndex:0];
+    AVAssetReaderOutput * output = [mMovieReader.outputs objectAtIndex:0];
     CMSampleBufferRef sampleBuffer = [output copyNextSampleBuffer];
     if (!sampleBuffer) {
         [localpool drain];
diff --git a/modules/highgui/src/cap_qtkit.mm b/modules/highgui/src/cap_qtkit.mm
index 580e8a0..f2f7963 100644
--- a/modules/highgui/src/cap_qtkit.mm
+++ b/modules/highgui/src/cap_qtkit.mm
@@ -297,7 +297,7 @@ bool CvCaptureCAM::grabFrame(double timeOut) {
     // method exits immediately"
     // using usleep() is not a good alternative, because it may block the GUI.
     // Create a dummy timer so that runUntilDate does not exit immediately:
-    [NSTimer scheduledTimerWithTimeInterval:100 target:nil selector:@selector(doFireTimer:) userInfo:nil repeats:YES];
+    [NSTimer scheduledTimerWithTimeInterval:100 target:capture selector:@selector(doFireTimer:) userInfo:nil repeats:YES];
     while (![capture updateImage] && (total += sleepTime)<=timeOut) {
         [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:sleepTime]];
     }
diff --git a/modules/java/CMakeLists.txt b/modules/java/CMakeLists.txt
index 1ef2a12..63d5db1 100644
--- a/modules/java/CMakeLists.txt
+++ b/modules/java/CMakeLists.txt
@@ -247,7 +247,7 @@ if(ANDROID)
     # build the library project
     # normally we should do this after a native part, but for a library project we can build the java part first
     add_custom_command(OUTPUT "${JAR_FILE}" "${JAR_FILE}.dephelper"
-                       COMMAND ${ANT_EXECUTABLE} -q -noinput -k debug
+                       COMMAND ${ANT_EXECUTABLE} -q -noinput -k debug -Djava.target=1.6 -Djava.source=1.6
                        COMMAND ${CMAKE_COMMAND} -E touch "${JAR_FILE}.dephelper" # can not rely on classes.jar because different versions of SDK update timestamp at different times
                        WORKING_DIRECTORY "${OpenCV_BINARY_DIR}"
                        DEPENDS ${step3_depends}
diff --git a/modules/java/android_test/CMakeLists.txt b/modules/java/android_test/CMakeLists.txt
index 41f69e6..b56da4a 100644
--- a/modules/java/android_test/CMakeLists.txt
+++ b/modules/java/android_test/CMakeLists.txt
@@ -43,7 +43,7 @@ list(APPEND opencv_test_java_file_deps ${android_proj_target_files})
 add_custom_command(
     OUTPUT "${opencv_test_java_bin_dir}/bin/OpenCVTest-debug.apk"
     COMMAND ${CMAKE_COMMAND} -E copy "${OpenCV_BINARY_DIR}/lib/${ANDROID_NDK_ABI_NAME}/libopencv_java.so" "${opencv_test_java_bin_dir}/libs/${ANDROID_NDK_ABI_NAME}/libopencv_java.so"
-    COMMAND ${ANT_EXECUTABLE} -q -noinput -k debug
+    COMMAND ${ANT_EXECUTABLE} -q -noinput -k debug -Djava.target=1.6 -Djava.source=1.6
     COMMAND ${CMAKE_COMMAND} -E touch "${opencv_test_java_bin_dir}/bin/OpenCVTest-debug.apk" # needed because ant does not update the timestamp of updated apk
     WORKING_DIRECTORY "${opencv_test_java_bin_dir}"
     MAIN_DEPENDENCY "${opencv_test_java_bin_dir}/${ANDROID_MANIFEST_FILE}"
diff --git a/modules/ml/src/svm.cpp b/modules/ml/src/svm.cpp
index 594a43a..a8e159f 100644
--- a/modules/ml/src/svm.cpp
+++ b/modules/ml/src/svm.cpp
@@ -1880,7 +1880,7 @@ bool CvSVM::train_auto( const CvMat* _train_data, const CvMat* _responses,
         qsort(ratios, k_fold, sizeof(ratios[0]), icvCmpIndexedratio);
         double old_dist = 0.0;
         for (int k=0; k<k_fold; ++k)
-            old_dist += abs(ratios[k].val-class_ratio);
+            old_dist += std::abs(ratios[k].val-class_ratio);
         double new_dist = 1.0;
         // iterate to make the folds more balanced
         while (new_dist > 0.0)
@@ -1897,7 +1897,7 @@ bool CvSVM::train_auto( const CvMat* _train_data, const CvMat* _responses,
             qsort(ratios, k_fold, sizeof(ratios[0]), icvCmpIndexedratio);
             new_dist = 0.0;
             for (int k=0; k<k_fold; ++k)
-                new_dist += abs(ratios[k].val-class_ratio);
+                new_dist += std::abs(ratios[k].val-class_ratio);
             if (new_dist < old_dist)
             {
                 // swapping really improves, so swap the samples
diff --git a/modules/ocl/test/test_arithm.cpp b/modules/ocl/test/test_arithm.cpp
index 29976b6..5480f58 100644
--- a/modules/ocl/test/test_arithm.cpp
+++ b/modules/ocl/test/test_arithm.cpp
@@ -879,8 +879,8 @@ OCL_TEST_P(MinMaxLoc, MAT)
             minlocVal_ = src1_roi.at<float>(minLoc_);
             maxlocVal = src1_roi.at<float>(maxLoc);
             maxlocVal_ = src1_roi.at<float>(maxLoc_);
-            error0 = ::abs(src1_roi.at<float>(minLoc_) - src1_roi.at<float>(minLoc));
-            error1 = ::abs(src1_roi.at<float>(maxLoc_) - src1_roi.at<float>(maxLoc));
+            error0 = std::abs(src1_roi.at<float>(minLoc_) - src1_roi.at<float>(minLoc));
+            error1 = std::abs(src1_roi.at<float>(maxLoc_) - src1_roi.at<float>(maxLoc));
         }
         if (depth == 6)
         {
@@ -888,8 +888,8 @@ OCL_TEST_P(MinMaxLoc, MAT)
             minlocVal_ = src1_roi.at<double>(minLoc_);
             maxlocVal = src1_roi.at<double>(maxLoc);
             maxlocVal_ = src1_roi.at<double>(maxLoc_);
-            error0 = ::abs(src1_roi.at<double>(minLoc_) - src1_roi.at<double>(minLoc));
-            error1 = ::abs(src1_roi.at<double>(maxLoc_) - src1_roi.at<double>(maxLoc));
+            error0 = std::abs(src1_roi.at<double>(minLoc_) - src1_roi.at<double>(minLoc));
+            error1 = std::abs(src1_roi.at<double>(maxLoc_) - src1_roi.at<double>(maxLoc));
         }
 
         EXPECT_DOUBLE_EQ(minVal_, minVal);
@@ -993,8 +993,8 @@ OCL_TEST_P(MinMaxLoc, MASK)
             minlocVal_ = src1_roi.at<float>(minLoc_);
             maxlocVal = src1_roi.at<float>(maxLoc);
             maxlocVal_ = src1_roi.at<float>(maxLoc_);
-            error0 = ::abs(src1_roi.at<float>(minLoc_) - src1_roi.at<float>(minLoc));
-            error1 = ::abs(src1_roi.at<float>(maxLoc_) - src1_roi.at<float>(maxLoc));
+            error0 = std::abs(src1_roi.at<float>(minLoc_) - src1_roi.at<float>(minLoc));
+            error1 = std::abs(src1_roi.at<float>(maxLoc_) - src1_roi.at<float>(maxLoc));
         }
         if (depth == 6)
         {
@@ -1002,8 +1002,8 @@ OCL_TEST_P(MinMaxLoc, MASK)
             minlocVal_ = src1_roi.at<double>(minLoc_);
             maxlocVal = src1_roi.at<double>(maxLoc);
             maxlocVal_ = src1_roi.at<double>(maxLoc_);
-            error0 = ::abs(src1_roi.at<double>(minLoc_) - src1_roi.at<double>(minLoc));
-            error1 = ::abs(src1_roi.at<double>(maxLoc_) - src1_roi.at<double>(maxLoc));
+            error0 = std::abs(src1_roi.at<double>(minLoc_) - src1_roi.at<double>(minLoc));
+            error1 = std::abs(src1_roi.at<double>(maxLoc_) - src1_roi.at<double>(maxLoc));
         }
 
         EXPECT_DOUBLE_EQ(minVal_, minVal);
diff --git a/modules/ts/src/gpu_test.cpp b/modules/ts/src/gpu_test.cpp
index 6f839c3..21d9ad9 100644
--- a/modules/ts/src/gpu_test.cpp
+++ b/modules/ts/src/gpu_test.cpp
@@ -418,8 +418,8 @@ namespace cvtest
 
             if (dist < maxPtDif &&
                 fabs(p1.size - p2.size) < maxSizeDif &&
-                abs(p1.angle - p2.angle) < maxAngleDif &&
-                abs(p1.response - p2.response) < maxResponseDif &&
+                std::abs(p1.angle - p2.angle) < maxAngleDif &&
+                std::abs(p1.response - p2.response) < maxResponseDif &&
                 p1.octave == p2.octave &&
                 p1.class_id == p2.class_id)
             {
diff --git a/platforms/android/android.toolchain.cmake b/platforms/android/android.toolchain.cmake
index b540ea4..b4b257a 100644
--- a/platforms/android/android.toolchain.cmake
+++ b/platforms/android/android.toolchain.cmake
@@ -1613,13 +1613,13 @@ endmacro()
 
 
 macro( ANDROID_GET_ABI_RAWNAME TOOLCHAIN_FLAG VAR )
- if( "${TOOLCHAIN_FLAG}" STREQUAL "ARMEABI" )
+ if( "x${TOOLCHAIN_FLAG}" STREQUAL "xARMEABI" )
   set( ${VAR} "armeabi" )
- elseif( "${TOOLCHAIN_FLAG}" STREQUAL "ARMEABI_V7A" )
+ elseif( "x${TOOLCHAIN_FLAG}" STREQUAL "xARMEABI_V7A" )
   set( ${VAR} "armeabi-v7a" )
- elseif( "${TOOLCHAIN_FLAG}" STREQUAL "X86" )
+ elseif( "x${TOOLCHAIN_FLAG}" STREQUAL "xX86" )
   set( ${VAR} "x86" )
- elseif( "${TOOLCHAIN_FLAG}" STREQUAL "MIPS" )
+ elseif( "x${TOOLCHAIN_FLAG}" STREQUAL "xMIPS" )
   set( ${VAR} "mips" )
  else()
   set( ${VAR} "unknown" )
@@ -1652,7 +1652,7 @@ if( NOT PROJECT_NAME STREQUAL "CMAKE_TRY_COMPILE" )
                 ANDROID_APP_PIE
                 )
   if( DEFINED ${__var} )
-   if( "${__var}" MATCHES " ")
+   if( "${${__var}}" MATCHES " ")
     set( __toolchain_config "${__toolchain_config}set( ${__var} \"${${__var}}\" CACHE INTERNAL \"\" )\n" )
    else()
     set( __toolchain_config "${__toolchain_config}set( ${__var} ${${__var}} CACHE INTERNAL \"\" )\n" )
diff --git a/samples/gpu/farneback_optical_flow.cpp b/samples/gpu/farneback_optical_flow.cpp
index e33c07e..8b8c7d0 100644
--- a/samples/gpu/farneback_optical_flow.cpp
+++ b/samples/gpu/farneback_optical_flow.cpp
@@ -24,8 +24,8 @@ static void colorizeFlow(const Mat &u, const Mat &v, Mat &dst)
     minMaxLoc(u, &uMin, &uMax, 0, 0);
     double vMin, vMax;
     minMaxLoc(v, &vMin, &vMax, 0, 0);
-    uMin = ::abs(uMin); uMax = ::abs(uMax);
-    vMin = ::abs(vMin); vMax = ::abs(vMax);
+    uMin = std::abs(uMin); uMax = std::abs(uMax);
+    vMin = std::abs(vMin); vMax = std::abs(vMax);
     float dMax = static_cast<float>(::max(::max(uMin, uMax), ::max(vMin, vMax)));
 
     dst.create(u.size(), CV_8UC3);
